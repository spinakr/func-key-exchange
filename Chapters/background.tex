\chapter{Background}
\label{chp:background} 
This chapter will present and discuss principles and schemes from which the project later rely. Charm is the framework used to implement the schemes, this will be described to some extent first, before continuing on to important principles and constructions which are used in the key exchanges mechanisms later.

\section{Charm}
Charm\cite{DBLP:Charm13} is a prototyping framework for cryptographic systems. It includes all the tools needed to implement most crypto systems, as well as keeping a collection of reusable code. The idea is to make it sufficiently easy to prototype systems which earlier only existed in research papers without actual implementations. It is of course possible to implement all schemes using other, lower level design methods, which may make for better and more efficient implementations. Most of the tools needed may be available but to combine and make good use of these is not easy. Charm focus on being readable and efficient to use. Several existing libraries is used to provide primitives needed, such as pairing groups and modular arithmetics. The design and implementation of Charm is described in detail in "Charm: a framework for rapidly prototyping cryptosystems"\cite{DBLP:Charm13}. Implementations from Charm will be used in this project to implement other protocols. Schemes from the Charm library of implemented schemes will be used as examples to describe protocols in the background chapter.

\section{Public Key Encryption}\label{sec:pke}
Public key cryptography or asymmetric cryptography allows encryption of messages without the parties sharing a secret key. Each user have a pair of keys, one public and one private key. The private key is used to decrypt and sign messages for authentication, while the public key - known publicly - is used to encrypt messages. 
\begin{itemize}
\item \textbf{Setup} - takes the security parameters, depending on the implementation, and outputs a public/private key pair.
\item \textbf{ Encryption } - takes the public key of the receiver as input together with the message, outputs a cipher text. Only the corresponding private key can decrypt.
\item \textbf{ Decryption } - uses the private key to decrypt the message.
\end{itemize}

This setup can also be used to achieve message authentication using digital signatures. Either by the use of the same algorithms as mentioned above or with separate ones alongside these. A common problem with public key crypto systems is how you are supposed to trust that a given public key used to sign something really belongs to the claimed owner. This issue is normally dealt with using a trusted \gls{ca} issuing certificates binding a public key to a user identity. The \gls{ca} has a public/private key pair, which is used to sign certificates on request. Initially the \gls{ca} have to publish its public key together with a CA certificate. This is stored in the browsers of users trusting it. A user will typically send a signed certificate request to the \gls{ca}, including the identity to be associated with the public key. The \gls{ca} verifies the request signature and produces a certificate which is signed using the \glspl{ca} own public key. When signing, the user will include this certificate as profe of his identity, which can be verified by anybody in possession of the \glspl{ca} public key and CA certificate. 


\section{Linear Secret Sharing}\label{subsec:lsss}
In many cases it may be desirable to use more than one key when encrypting, and later require a subset of these when decrypting. This concept is called secret sharing or secret splitting - a secret is "divided" into $n$ pieces which then is distributed. To recover the message $k$ of these $n$ pieces needs to be present. Secret sharing is often used to store highly sensitive keys, typically private keys of a \gls{ca} or other keys which should not be assessible by a single user alone. For the cause of this project only \gls{lsss} is described as this is a key component in of the constructions used later. 

\paragraph{A linear secret sharing scheme\cite{lsss}}, defined by $(k,n)$, where $n$ are the number of shares and $k$ the threshold to allow recovery, are defined as following.\\
\begin{itemize}
\item \textbf{Setup} -  $A$ is a public $k\times n$ matrix with entries chosen from $F = \mathbb{Z}_m^*$ with generator $m$, a prime. $x=(x_1,x_2,\dots,x_t)^K$ is a secret vector from $F^k$. $a_{ij}$ is element at the $i$th row in the $j$th column of the matrix $A$.
\item \textbf{Dealing phase} - A secret vector $x \in F^k$ where $x_1$ is the secret value, while the rest of the values are random from $F$. Each user get a share $y_i \in F$.
\centerline{$y_i = a_{i1}x_1 + a_{i2}x_2 + \dots + a_{ik}x_k$}
For the $(k,n)$ threshold system there will be $n$ such schemes and thus a $(n\times k)$ linear system $Ax=y$.
The shares $y_i$ are sent to the users, while $A$ are made public.
\item \textbf{Recovery phase} - Consist of solving a linear system of equations made of combining the users equations forming a matrix $A_U$ where $U = {u_1, \dots, u_k}$ is the users participating in the recovery. The solution is then found by solving 
\centerline{$A_Ux=y_U$}, where $y_U$ is the vector of secrets of the users. The secret is found as the first coordinate of the solution.
\end{itemize}

\subsection{Shamir Secret  Sharing}\label{sec:secret_sharing}
 Shamir's secret sharing scheme \cite{shamir_share} was one of the first implementations of secret sharing, and acts as an example on how these schemes may look. The main idea behind the scheme is that given $k$ points in a plane $(x_1,y_1), ... (x_k,y_k)$ there is only one polynomial $y(x)$ of degree $k-i$ such that $y(x_i) = y_i$ for all $i$. We can thus chose a prime $p$, larger than the desired number of shadows, and a random number $a < p$. Then equation \ref{eq:polynom} is the polynomial used, with the secret $m$. The shadows are $(x, y(x), p) , x=\left\{ {1,2, ... ,n}\right\}$ of which only $k$ is needed to recover $m$. With $k$ shadows we obtain a set of $k$ equations with $k$ unknown which is solved unambiguously.

\begin{equation}
 y(x) = m + a_1*x + a_2*x^2 + ... + a_{k-1} * x^{k-1} 
\end{equation}\label{eq:polynom}



\section{Pairing-based encryption}
Let $G$ be a group of prime order $q$ with generator $g$. $x,z,y \in \mathbb{Z}_q$. The \emph{Discrete-logarithm} problem says that it is hard to obtain $x$ from $g^x$ and $g$. Further we have the \emph{\gls{cdh}} which extends this saying that it is hard to calculate $g^{xy}$ from the tuple $(g, g^x, g^y)$. Finally we can say that it is hard to determine if $z=xy$ given $(g, g^x, g^y, g^z)$ - \emph{\gls{ddh}}. These assumptions are used, and relied on, in earlier crypto systems. The systems explored in this project use pairing of the traditional group assumptions. The idea behind this is to use a mapping between two cryptographic groups which allows the creation of new schemes based on the reduction of one of the problems from earlier.\todo{rewrite sentence} The most renowned pairing-based construction is the \emph{bilinear map}. $G_1$ and $G_2$ are groups of prime order $q$. If $e: G_1 \times G_1 \rightarrow G_2$ then the mapping $e$ should have the following properties to be useful: 
\begin{itemize}
\item Bilinearity - for all $P, Q \in G_1$ and all $a,b \in \mathbb{Z}_q$, then $e(P^a, Q^b) = e(P, Q)^{ab}$
\item Non-Degeneracy - if $P \neq 0 \implies e(P,P) \neq 1$
\end{itemize}
The Weil and Tate pairing are the most used pairings where these properties hold. The pairings usually consist of one elliptic curve paired with a finite field. 
The point with all this is that problems in the first group may not all be hard in the pairing group. Discrete-logarithms are still hard since $e(g,g)$, $e(g,g^a)$ $\in G_T$ is as hard as $g,g^a \in G$ where $G_T$ is the pairing group.
For \gls{ddh} though, we can see that to test if $z=xy$ given $g, g^x, g^y, g^z$, we can just check if $e(g, g^z) = e(g^x, g^y)$. \Gls{ddh} is thus replaced by \gls{bddh} which is defined as - given $h, g, g^x, g^y, e(h,g)^z$ it is hard to decide if $xy = z$ \cite{pairing-survey}. These definitions made it possible to implement \gls{ibe} and \gls{abe} as described in the next section.
\todo[inline]{not sure if this is a precise understanding of pairings(?)}

\section{Functional Encryption}
Before public key cryptography was introduced, secure communication was only achieved when two parties possessed the same secret key which could be used to encrypt and decrypt messages between them. This was changed with the introduction of public key cryptography as mentioned in \ref{sec:pke}. Now, many years later, this is no longer sufficient to cover the new notion of the Internet - with distributed systems and cloud-based services. Standard public key encryption schemes focus on fully encrypting or decrypting plain texts - especially when decrypting you either have the correct key, which would allow you to recover the plain text, or you canâ€™t. But what if you would like to allow certain keys to decrypt only a part of the plain text, or output some information about it to anybody? It could in example be useful to allow the mail service to know some meta data, while still not allowing it to decrypt the whole thing, the private key of the server could be allowed to decrypt specific parts decideding if a e-mail is spam or not.
\par Functional encryption, as described by Boneh et al.\cite{boneh2012functional}, describes an idea where different keys produce different plain text - a function of the cipher text. One key might be used to decrypt only a specified part of the cipher text - a "function" of it. Functional schemes also make it possible for several different keys to decrypt a message if they satisfy a policy, completely or partially. This allows us to encrypt a message for a certain group of users, and later grant new users access to it without having to decrypt it. A \gls{kms} issues keys based on some characteristics, which can be used to decrypt message encrypted previously. 
\par The term "Functional Encryption" has come to describe a wide spectrum of modern cryptography techniques, including identity-based encryption and attribute-based encryption, which will be described and demonstrated in the following sections. These schemes relates to functional encryption since it allow several independent keys to decrypt, or uses some function to decrypt without the need of \emph{one} specific key, as in symmetric key encryption.


\subsection{Identity-based encryption}\label{subsec:IBE}
Public key systems rely on a trusted \gls{ca}, issuing certificates assuring the binding between a public key and an claimed owner. The user generate their key pair themselves, then the public key has to be signed by a trusted \glsdesc{ca}. Now the public key can be verified, assuring that nobody is forging it. Each user has to keep a large archive of keys belonging to whom he wants to communicate. More problems arise when a user wants to declare his key invalid and revoke it. All this makes for a big infrastructure of \glspl{ca} and revocation mechanisms. \Gls{ibe}\cite{DBLP:ibe} introduce an approach where a users id act as the public key, this identity can typically be an e-mail address or a user name. There are no \glspl{ca}, but instead each domain have a \gls{kms} with a master public/secret key pair. The master public key can be used in conjunction with the id of the desired receiver to encrypt the message. The receiver can then decrypt the cipher text using his private key. This private key is extracted by the \gls{kms} from the identity of the specific user. The removal of the \glspl{ca} introduces another problem, since the users no longer generate their own key pair, a lot power is now in the hands of the \gls{kms}. Algorithms using a \gls{kms} have to take into consideration that this service have complete control over all keys, and can in fact generate any key. The life cycle of a system implementing \gls{ibe} consist of 4 algorithms. 

\begin{itemize}
\item \textbf{ Setup } - Taking some security parameters $1^k$ a master public/secret key pair $(mpk, msk)$ are generated.
\item \textbf{ Key } delegation - Using $mpk$, $msk$ and some $id$ generating a $sk_{id}$ for the specific user. 
\item \textbf{ Encryption } - Encrypts a message $m$ using $mpk$ and the $id$ of the desired receiver. 
\item \textbf{ Decryption } - Decrypts cipher text $ct$ using $sk_{id}$, obtaining $m$. 
\end{itemize}
\newpage
Figure \ref{fig:ibenc} demonstrate a \gls{ibe} scheme from the Charm framework and the implementation described by Waters\cite{ibe_waters09}.


\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\begin{figure}[H]
\begin{lstlisting}[language=bash, xleftmargin=2em, frame=single, framexleftmargin=1.5em, breaklines=true, numbers=left, numbersep=5pt, numberstyle=\tiny\color{mygray}]

>>> from charm.toolbox.pairinggroup import PairingGroup, GT
>>> from charm.schemes.ibenc.ibenc_waters09 import DSE09
>>> group = PairingGroup('SS512')
>>> ibe = DSE09(group)
>>> mpk, msk = ibe.setup()
>>> ID = "student@stud.ntnu.no"
>>> secret_key = ibe.keygen(mpk, msk, ID)
>>> msg = group.random(GT)
>>> ct = ibe.encrypt(mpk, msg, ID)
>>> decrypted_msg = ibe.decrypt(ct, secret_key)
>>> msg == decrypted_msg
True
>>> 

\end{lstlisting}
\caption{Demo run of identity-based encryption from Charm.}
\label{fig:ibenc}
\end{figure}

First the required dependencies are imported from the Charm toolbox, in this example the pairing group and the \gls{ibe} class. On line 4 the pairing group is initiated with a elliptic curve with a 512-bit base - thus "SS512". Next the class object is initiated using the previously created group object. Line 6 to 13 demonstrate a \gls{ibe} cycle with setup, keygen, encryption and decryption.
Notice that anybody can encrypt a message for any user without having a public key stored locally, we simply use the master public key together with the identity of the recipient. This removes a lot of overhead known from \gls{pki}, we now only need one public key for each domain. \Gls{ibe} is a somewhat more intuitive scheme, since the identity of the recipients is used as the public key, thus no connection between different public keys and user identities have to be stored.

\subsection{Attribute-based encryption}\label{subsec:ABE}

Attribute-based encryption as explained by Goyal et al. \cite{ABE} introduce an encryption scheme based on user attributes, from which the secret key is generated. This is similar to \gls{ibe}, but with the possibility of more than one "ID". Messages are encrypted using a access policy of several attributes, and only keys satisfying the access structure can decrypt the cipher text. This is typically useful in cases where the encryptor does not care about who decrypts as long as they satisfy the correct attributes or a set of them. Each user will have a private key corresponding to his set of attributes, in each domain. When encrypting, the policy is specified, this is typically a access tree where the attributes required are leaf nodes and internal nodes are "AND" or "OR"-gates. Different combinations of attributes may therefore be able to decrypt. The logical gates can be used to construct threshold requirements, where we require $k$ out of $n$ attributes. The encryptor can in example encrypt a message with the policy\\ \centerline{("NTNU" and "5th year" and Telematics dpmt.) or} \\ \centerline{("Professor" and "Telematics dpmt.") or "admin"}
Now a user with either the "admin"-attribute or a set including "NTNU", "5th year" and "Telematics dpmt" would be able to decrypt. A user can thus create access structures allowing his id or some combination of other attributes to decrypt without having the attributes himself. It is worth noticing that \gls{abe} is a generalization of \gls{ibe} since an identity can be used as an attribute. The algorithm  have a similar structure as the one in \gls{ibe} (\ref{subsec:IBE}).

\begin{itemize}
\item \textbf{ Setup } - Taking some security parameters $1^k$ a master public/secret key pair $(mpk, msk)$ are generated.
\item \textbf{ Key generation } - Using $mpk$, $msk$ and some $S$ describing the set of attributes - generates a $sk$ for the specific attribute combination. 
\item \textbf{ Encryption } - Encrypts a message $m$ using $mpk$ and an access structure $A$ describing the policy of the encryption. The attributes in the access structure will define who's able to decrypt. 
\item \textbf{ Decryption } - Decrypts cipher text $ct$ using $sk$ corresponding to an attribute set $S$, obtaining $m$. 
\end{itemize}


Charm also include an implemented \gls{abe} scheme based on Waters\cite{abe_waters09}, which can be used to describe how the algorithms work. This construction will later be used in the implementation of a prototype attribute-based key exchange application. The implementations are written in python and are thus easily readable. A walkthrough of the \gls{abe} protocol using the implementation will be used to demonstrate the algorithms mentioned. The implementation and a sample run of the methods are included for each of the algorithms (the memory references are removed to make it more compact). Figure \ref{fig:abe_math} describes the \gls{cpabe} scheme of Waters\cite{abe_waters09} from which the implementation is based. The two definitions can be followed in parallel and it can be seen that they in fact define the same thing, the mathematical presentation might be easier to follow as the symbols are more clear, while the python code use programmatic variable names. The important point to emphasis is that the code is based directly on the figure definition, which is provided to make the code easier to follow.

\begin{figure}[H]
\begin{mdframed}
\paragraph{Setup} - Group $G$ of prime order $p$ is chosen from generator $g$. $\alpha, a \in \mathbb{Z}_p$ are generated at random. $H: \{0,1\}\* \rightarrow G$ is a hash function. The master public key is then $mpk = g, e(g,g)^{\alpha}, g^a$, where $e()$ is a pairing function as described in \ref{subsec:lsss}. The master secret key is $msk = g^{\alpha}$.
\
\paragraph{Key generation} - takes $msk$ and a set $S$ of attributes as arguments and randomly chose $t \in \mathbb{Z}_p$. The constructed private key is then \\ \centerline{$K = g^{\alpha}g^{at}\hspace{1cm} L = g^t \hspace{1cm}   \forall x\in S, K_x = H(x)^t$}.
\\
\paragraph{Encryption} - Takes $mpk$ and a message $m$ as arguments, together with a access structure $(M,p)$ where $M$ is an $l\times n$ matrix and $p$ is a function associating rows in M with attributes. A random vector $\vec{v} = (s, y_2, ..., y_n)\in \mathbb{Z}_p^n$ is chosen, this will be used to share the encryption exponent $s$. Now calculate $\lambda_i = \vec{v} M_i$, for $i=1$ to $l$, where $M_i$ is the $i$th row of the matrix $M$. $r_1,\dots,r_l \in \mathbb{Z}_p$. The cipher text is then ct = \\
\centerline{$C=me(g,g)^{\alpha s}$, $C'=g^s$,}
\centerline{($C_1 = g^{\alpha \lambda_1} H(p(1))^{-r_1}, D_1=g^{r_1}$,$\dots$,$C_n = g^{\alpha \lambda_n} H(p(n))^{-r_n}, D_n=g^{r_n}$)}.
The access structure $(M,p)$ is attached to the cipher text as well.
\\
\paragraph{Decryption} - Recovers the plain text from a cipher text for a access structure, using private key corresponding to attribute set S. Let $I \subset \{1,2,\dots,l\}$ be defined as $I = \{i : p(i) \in S\}$. Then, chose $\{\omega \in \mathbb{Z}_p\}_{i\in I}$ so that if $\{\lambda_i\}$ are valid shares of a secret with access matrix $M$, then $\sum_{i\in I}\omega_i \lambda_i = s$. Now the algorithm computes
\centerline{$\frac{C',K }{\prod_{i\in I}(e(C_i,L)e(D_i,K_{p(i)}))^{\omega_i}} = \frac{e(g,g)^{\alpha s}e(g,g)^{ast}}{(\prod_{i\in I}e(g,g)^{ta\lambda_i\omega_i})}=e(g,g)^{\alpha s}$}
\centerline{We have from the encryption method that $C=me(g,g)^{\alpha s}$, }
\centerline{and $m$ can thus be dived out.}


\caption{\gls{abe}, Waters\cite{abe_waters09}}
\label{fig:abe_math}
\end{mdframed}
\end{figure}
\subsubsection{Setup}

\begin{figure}[H]
\begin{minted}[frame=single]
{python}
def setup(self):
    g1, g2 = group.random(G1), group.random(G2)
    alpha, a = group.random(), group.random()        
    e_gg_alpha = pair(g1,g2) ** alpha
    msk = {'g1^alpha':g1 ** alpha, 'g2^alpha':g2 ** alpha} 
    pk = {'g1':g1, 'g2':g2, 'e(gg)^alpha':e_gg_alpha, 
    'g1^a':g1 ** a, 'g2^a':g2 ** a}
    return (msk, pk)
\end{minted}
\caption{\Gls{abe} setup function}
\label{code:setupfunc}
\end{figure}

\begin{figure}[H]
\begin{lstlisting}[language=bash, frame=single, breaklines=true ]
>>> from charm.toolbox.pairinggroup import PairingGroup,ZR,
    G1,G2,GT,pair
>>> from charm.schemes.abenc.abenc_waters09 import CPabe09
>>> groupObj = PairingGroup('SS512')
>>> cpabe = CPabe09(groupObj)
>>> (msk, mpk) = cpabe.setup()
>>> print msk
    {'g1^alpha': <pairing.Element object at 0x>, 
    'g2^alpha': <pairing.Element object at 0x>}
>>> print pk
    {'g1^a': <pairing.Element object at 0x>, 
    'g2^a': <pairing.Element object at 0x>, 
    'g2': <pairing.Element object at 0x>, 
    'g1': <pairing.Element object at 0x>, 
    'e(gg)^alpha': <pairing.Element object at 0x>}
>>>
\end{lstlisting}
\caption{Demo running the setup function}
\label{fig:setupfunc}
\end{figure}

The class in figure \ref{code:setupfunc} is demonstrated in figure \ref{fig:setupfunc}. The environment from which the methods are run have defined an elliptic curve with bilinear mapping. The pairing $e(g_1,g_2)$  correspond to $e(g,g)$ in \ref{fig:abe_math}.  The master public and private key pair is stored locally at a server acting as a \gls{kms}. After initializing the protocol we can generate a secret key using a defined set of attributes. For this we have the key generation method as following. This will be used by the \gls{kms} to generate secret keys for users in the protocol. How these keys are distributed is a separate concern which is not dealt with in this report. It is demonstrated how the keys are generated but now how they are distributed to the correct users. It is assumed that each user can receive their key securely from the \gls{kms}, and trust if to be reliable.


\subsubsection{Key Generation}
\begin{figure}[H]
\begin{minted}[frame=single]
{python}
def keygen(self, pk, msk, attributes):        
    t = group.random()
    K = msk['g2^alpha'] * (pk['g2^a'] ** t)
    L = pk['g2'] ** t
    k_x = [group.hash(unicode(s), G1) ** t for s in attributes]
    
    K_x = {}
    for i in range(0, len(k_x)):
        K_x[ attributes[i] ] = k_x[i]    

    attributes = [unicode(a) for a in attributes]

    key = { 'K':K, 'L':L, 'K_x':K_x, 'attributes':attributes }
    return key

\end{minted}
\caption{\Gls{abe} key generation function}
\label{code:keygenfunc}
\end{figure}

\begin{figure}[H]
\begin{lstlisting}[language=bash, frame=single, breaklines=true ]
>>> attr_list = ['THREE', 'ONE', 'TWO']
>>> secret_key = cpabe.keygen(pk, msk, attr_list)
>>> print secret_key
    {'K_x': {'TWO': <pairing.Element object at 0x>, 
             'THREE': <pairing.Element object at 0x>, 
             'ONE': <pairing.Element object at 0x>}, 
     'K': <pairing.Element object at 0x0>, 
     'L': <pairing.Element object at 0x>, 
     'attributes': [u'THREE', u'ONE', u'TWO']}
>>> 
\end{lstlisting}
\caption{Demo running the key generation function}
\label{fig:keygenfunc}

\end{figure}

The secret key includes a list of all the attributes with a corresponding hash value raised to the power of a random value $t \in \mathbb{Z}_p$. Additionally a list of the unicode representations of the attributes are added - this will later be used when decrypting, to check if a given key comply with the policy given in the cipher text. The list of attributes for the secret key are compared with the attributes in the access structure before decrypting,this way we avoid actually trying to decrypt if the key doesn't contain the correct attributes. The public parameters in $pk$ must be published together with the secret keys, so that each user have a key pair consisting of their personal secret key, and the master public key. A major problem when doing \gls{abe} is preventing collusion attacks, where a group of users try to combine their attributes trying to satisfy a more restrictive access structure then what their individual sets of attributes allow. This construction avoids this by randomizing each key with a generated exponent $t$. When decrypting, each share will have this $t$ in the exponent, which is supposed to bind the components of each key together. Combining two keys would have the value of $t$ different so they would not work together.  During decryption these shares are only relevant to the particular key used in that exact run of the decryption algorithm.



\subsubsection{Encryption}
\begin{figure}[H]
\begin{minted}[frame=single]
{python}
def encrypt(self, pk, M, policy_str):
    # Extract the attributes as a list
    policy = util.createPolicy(policy_str)        
    p_list = util.getAttributeList(policy)
    s = group.random()
    C_tilde = (pk['e(gg)^alpha'] ** s) * M
    C_0 = pk['g1'] ** s
    C, D = {}, {}
    secret = s
    shares = util.calculateSharesList(secret, policy)

    # ciphertext
    for i in range(len(p_list)):
        r = group.random()
        if shares[i][0] == p_list[i]:
           attr = shares[i][0].getAttribute() 
           C[ p_list[i] ] = ((pk['g1^a'] ** shares[i][1]) *
           (group.hash(attr, G1) ** -r))
           D[ p_list[i] ] = (pk['g2'] ** r)
    
    return { 'C0':C_0, 'C':C, 'D':D , 'C_tilde':C_tilde, 
            'policy':unicode(policy_str), 'attribute':p_list }

\end{minted}
\caption{\Gls{abe} encryption function}
\label{code:encfunc}
\end{figure}

\begin{figure}[H]
\begin{lstlisting}[language=bash, frame=single, breaklines=true ]
>>> policy = '((ONE or THREE) and (TWO or FOUR))'
>>> msg = group.random(GT)
>>> cipher_text = cpabe.encrypt(master_public_key, msg, policy)
>>> print msg
>>> print cipher_text
    {
    'C': {
            u'TWO': <pairing.Element object at 0x>, 
            u'FOUR': <pairing.Element object at 0x>, 
            u'THREE': <pairing.Element object at 0>, 
            u'ONE': <pairing.Element object at 0x}, 
    'D': {
            u'TWO': <pairing.Element object at 0x>, 
            u'FOUR': <pairing.Element object at 08>, 
            u'THREE': <pairing.Element object at 0x>, 
            u'ONE': <pairing.Element object at 0x>}, 
    'attribute': [u'ONE', u'THREE', u'TWO', u'FOUR'], 
    'C_tilde': <pairing.Element object at 0x>, 
    'policy': u'((ONE or THREE) and (TWO or FOUR))', 
    'C0': <pairing.Element object at 0x>}
\end{lstlisting}  
\caption{Demo running the encryption function}
\label{fig:encfunc} 
\end{figure}


Before encrypting, a policy is specified, this will be the access structure used in the encryption. Since the protocol relies on pairings, only pairing elements can be used, a random message $m$ is thus generated from the group to be used in the demonstration. If we were to encrypt some kind of readable message we would need an adapter on top, mapping messages to pairing elements. This project focus on applications where this is not needed - random group elements is sufficient for the constructions presented later, the group elements can be hashed to transform it into a random string if needed. The encryption method starts off by extracting the attributes from the policy provided, then a random group object is generated and used together with the public key and the message to calculate a internal cipher text. This secret is then split into shares using \gls{lsss} as described in \ref{subsec:lsss}. Each share is associated with one attribute and a subset of these will be require to obtain $s$ when decrypting, according to the policy.
 
\subsubsection{Decryption}
\begin{figure}[H]
\begin{minted}[frame=single]
{python}
def decrypt(self, pk, sk, ct):
    policy = util.createPolicy(ct['policy'])
    pruned = util.prune(policy, sk['attributes'])
    if pruned == False:
        return False
    coeffs = util.getCoefficients(policy)
    numerator = pair(ct['C0'], sk['K'])
    
    # create list for attributes in order...
    k_x, w_i = {}, {}
    for i in pruned:
        j = i.getAttributeAndIndex()
        k = i.getAttribute()
        k_x[ j ] = sk['K_x'][k]
        w_i[ j ] = coeffs[j]
        
    C, D = ct['C'], ct['D']
    denominator = 1
    for i in pruned:
        j = i.getAttributeAndIndex()
        denominator *= ( pair(C[j] ** w_i[j], sk['L']) *
        pair(k_x[j] ** w_i[j], D[j]) )   
    return ct['C_tilde'] / (numerator / denominator)

\end{minted}
\caption{\Gls{abe} decryption function}
\label{code:dencfunc}
\end{figure}

\begin{figure}[H]
\begin{lstlisting}[language=bash, frame=single, breaklines=true ]
>>> decrypted = cpabe.decrypt(master_public_key, secret_key, cipher_text)
>>> decrypted == msg
True
>>> 
\end{lstlisting}
\caption{Demo running the decryption function}
\label{fig:dencfunc}
\end{figure}
Decryption is done using the public parameters and a secret key corresponding to a set of attributes. First step in the decryption is to compare the access structure and the attributes present in the secret key. If the policy is not fulfilled the method can return straight away. The pruned method performs this validation and returns a "pruned" list of attributes. This is the minimal subset of the attributes satisfying the policy - in example a set including both childes of a "OR" node would be pruned to only include one of these. Finally the secrets are combined and used to recover the message. The calculations can be recognized from the decryption method in figure \ref{fig:abe_math}.


\par
From the scheme described it is noticeable from the encryption method that anybody can in fact encrypt for any set of attributes, as long as they have the master public key. The authentication is not mutual, the encryptor doesn't have to have any specific attributes to be able to encrypt. The protocol only provide assurances that nobody without the correct attribute set can decrypt the message, this is sufficient when used as a public key encryption mechanism, but might not hold in cases where mutual authentication is required.

\section{Key Exchange}\label{sec:key_exchange}
A fundamental requirement in many cryptographic schemes is a way of establishing a common secret to be used later to achieve confidentiality or integrity. This is usually solved using a key exchange scheme, which can be between two are a group of parties. In this project the focus is on cases with several users must be allowed. In such group settings there are two types of environment, one when the users are known before the exchange are carried out and they stay the same throughout the life cycle, and one where users join and leave dynamically. Examples of the former are conference calls where the participants are known in advance, before setting up the call, while live chats may be the opposite. 

\subsection{Group Diffie-Hellman Key Exchange}\label{subsec:DH}
The Diffie-Hellmann key exchange algorithm in its original form allows two parties to jointly establish a common secret key which later can be used to encrypt traffic and etc. Since the introduction of the 2-party Diffie-Hellmann researchers tried to extend it to support groups of parties \cite{steiner1996diffie, groupDH}. These configurations allow several parties, typically in a multicast group or similar network, to establish a common session key. In the 2-party Diffie-Hellman a cyclic group G =  $\langle x \rangle$ of prime order $p$ is chosen carefully. Then each party chose a random number, $a$ and $b$, before $g^a$ and $g^b$ can be exchanged and the common secret key $g^{ab}$ computed. The group configuration of the scheme uses the same principle only with several participants as shown in Figure~\ref{fig:dhgroup}. The configuration is the same for $n$ players. The scheme starts of with the first player raising $g$ to the power of his private key and sends this value to the next player in the chain. He then raises the received value to the power of his private key and sends it, plus the intermediate values on to the next player, this continues until the last player receives the set, he can now compute the session key $g^{x_1,x_2.x_3,...,x_n}$. An attacker would have been able to see all the sent combinations, but none of these combine into the session key. New players can not easily join or leave since all previous players would have to update their set. 

\begin{figure}
\centering
\includegraphics[page=2, scale=0.7]{dhgroup.pdf}
\caption{D-H group key exchange}
\label{fig:dhgroup}
\end{figure}

\section{Hybrid Public key Encryption}\label{sec:hybrid}
A hybrid encryption scheme \cite{hybrid_enc} consists of a public key encryption technique and a symmetric key encryption technique, from which the former, \gls{kem}, is used to encrypt some key $K$, and the latter, \gls{dem}, encrypts the data. This setup can be applied using a variety of different cryptographic systems for both the \gls{kem} and \gls{dem}. 

\paragraph{Pgp/Gpg}\label{pgp}\cite{openpgp, koch2003gnu} is an extension to the classic public key scheme, combining the speed of symmetric key cryptography with the dynamic nature of public key systems. This is done by generating a random session key which is used to encrypt a message, this key is then encrypted using the public keys of each recipients and concatenated together with the cipher text. Pgp uses a hierarchy of trusted \glspl{ca} as described in \ref{sec:pke}, but also what is called a "web of trust" where users can sign the public keys of eachother to assure authenticity. This way users build a net of users verifying their identity in addition to the trusted \glspl{ca}.

\subsection{Key encapsulation mechanism}
\Gls{kem} \cite{kem_kurosawaP14} is a technique where a random key $K$ is generated together with its encryption $C$ - the encapsulation. This is useful for distribution of symmetric keys that can be used again to generate session keys for two or several parties, depending on the encapsulation mechanism. A \gls{kem} consists of three algorithms:
\begin{itemize}
\item \textbf{ Key generation } - generation of the symmetric key used by the \gls{dem}.
\item \textbf{ Encryption } - used to encrypt the generated key, usually using some public key.
\item \textbf{ Decryption } - reveals the symmetric key from the encapsulation.
\end{itemize}

This configuration will be used when constructing key exchange schemes using both \gls{ibe} and \gls{abe}. Hybrid encryption schemes are basically doing key exchange. The focus will be on the setting with several users doing key exchange, a sollution is then to use a hybrid scheme to exchange encapsulations of randomly generated symmetric keys which can be combined to one sessions key. This session key can then be used by the \gls{dem} to communicate securly.




