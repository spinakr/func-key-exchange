\chapter{Background}
\label{chp:background} 
This chapter will present and discuss principles and schemes from which the project later develops. Charm is the framework used to implement the schemes, this will be described to some extent first, before continuing on to important principles and constructions which are used in the key exchanges mechanisms later.

\section{Charm}
Charm \cite{DBLP:Charm13} is a prototyping framework for cryptographic systems. It includes all the tools needed to implement most crypto systems, as well as keeping a collection of reusable code. The idea is to make it sufficiently easy to prototype systems which earlier only existed in research papers without actual implementations. It is of course possible to implement all schemes using other, lower level design methods, which may make for better and more efficient implementations. Most of the tools needed may be available but to combine and make good use of these is not easy. 
\par Charm focuses on being readable and efficient to use. Several existing libraries are used to provide primitives needed, such as pairing groups and modular arithmetic. The design and implementation of Charm is described in detail in "Charm: a framework for rapidly prototyping cryptosystems"\cite{DBLP:Charm13}. Implementations from Charm will be used in this project to implement other protocols. Schemes from the Charm library of implemented schemes will be used as examples to describe protocols in the background chapter.


\section{Linear Secret Sharing}\label{subsec:lsss}
In many cases it may be desirable to use more than one key when encrypting, and later require a subset of these when decrypting. This concept is called secret sharing or secret splitting - a secret is "divided" into $n$ pieces which then is distributed. To recover the message $k$ of these $n$ pieces needs to be present. Secret sharing is often used to store highly sensitive keys, typically private keys of a \gls{ca} or other keys which should not be assessible by a single user alone. For the cause of this project only \gls{lsss} is described as this is a key component in many of the constructions used later. 

\paragraph{A linear secret sharing scheme \cite{lsss}}, defined by $(k,n)$, where $n$ are the number of shares and $k$ the threshold to allow recovery, are defined as following.\\
\begin{itemize}
\item \textbf{Setup} -  $A$ is a public $k\times n$ matrix with entries chosen from $F = \mathbb{Z}_m^*$ with generator $m$, a prime. $x=(x_1,x_2,\dots,x_t)^K$ is a secret vector from $F^k$. $a_{ij}$ is element at the $i$th row in the $j$th column of the matrix $A$.
\item \textbf{Dealing phase} - A secret vector $x \in F^k$ where $x_1$ is the secret value, while the rest of the values are random from $F$. Each user get a share $y_i \in F$.
\centerline{$y_i = a_{i1}x_1 + a_{i2}x_2 + \dots + a_{ik}x_k$}
For the $(k,n)$ threshold system there will be $n$ such schemes and thus a $(n\times k)$ linear system $Ax=y$.
The shares $y_i$ are sent to the users, while $A$ are made public.
\item \textbf{Recovery phase} - Consist of solving a linear system of equations made of combining the users equations forming a matrix $A_U$ where $U = {u_1, \dots, u_k}$ is the users participating in the recovery. The solution is then found by solving 
\centerline{$A_Ux=y_U$}, where $y_U$ is the vector of secrets of the users. The secret is found as the first coordinate of the solution.
\end{itemize}

\subsection{Shamir Secret  Sharing}\label{sec:secret_sharing}
 Shamir's secret sharing scheme \cite{shamir_share} was one of the first implementations of secret sharing, and acts as an example on how these schemes may look. The main idea behind the scheme is that given $k$ points in a plane $(x_1,y_1), ... (x_k,y_k)$ there is only one polynomial $y(x)$ of degree $k-i$ such that $y(x_i) = y_i$ for all $i$. We can thus chose a prime $p$, larger than the desired number of shares, and a random number $a < p$. Then equation \ref{eq:polynom} is the polynomial used, with the secret $m$. The shares are $(x, y(x), p) , x=\left\{ {1,2, ... ,n}\right\}$ of which only $k$ is needed to recover $m$. With $k$ shares we obtain a set of $k$ equations with $k$ unknown which is solved unambiguously.

\begin{equation}
 y(x) = m + a_1*x + a_2*x^2 + ... + a_{k-1} * x^{k-1} 
\end{equation}\label{eq:polynom}


\section{Public Key Encryption}\label{sec:pke}
Public key cryptography or asymmetric cryptography, as describe by ElGamal \cite{elgamal},  allows encryption of messages without the parties sharing a secret key. Each user have a pair of keys, one public and one private key. The private key is used to decrypt and sign messages for authentication, while the public key - known publicly - is used to encrypt messages. 
\begin{itemize}
\item \textbf{Key generation} - takes the security parameters, depending on the implementation, and outputs a public/private key pair.
\item \textbf{ Encryption } - takes the public key of the receiver as input together with the message, outputs a cipher text. Only the corresponding private key can decrypt.
\item \textbf{ Decryption } - uses the private key to decrypt the message.
\end{itemize}

This setup can also be used to achieve message authentication using digital signatures. Either by the use of the same algorithms as mentioned above or with separate ones alongside these. A common problem with public key crypto systems is how you are supposed to trust that a given public key used to sign something really belongs to the claimed owner. This issue is normally dealt with using a trusted \gls{ca} issuing certificates binding a public key to a user identity. The \gls{ca} has a public/private key pair, which is used to sign certificates on request. Initially the \gls{ca} have to publish its public key together with a CA certificate. This is stored in the browsers of users trusting it. A user will typically send a signed certificate request to the \gls{ca}, including the identity to be associated with the public key. The \gls{ca} verifies the request signature and produces a certificate which is signed using the \glspl{ca} own public key. When signing, the user will include this certificate as profe of his identity, which can be verified by anybody in possession of the \glspl{ca} public key and CA certificate. 




\section{Hybrid Public key Encryption}\label{sec:hybrid}
A hybrid encryption scheme \cite{hybrid_enc} consists of a public key encryption technique and a symmetric key encryption technique, from which the former, \gls{kem}, is used to encrypt some key $K$, and the latter, \gls{dem}, encrypts the data. This setup can be applied using a variety of different cryptographic systems for both the \gls{kem} and \gls{dem}. 

\paragraph{Pgp/Gpg}\label{pgp}\cite{openpgp, koch2003gnu} is an extension to the classic public key scheme, combining the speed of symmetric key cryptography with the dynamic nature of public key systems. This is done by generating a random session key which is used to encrypt a message, this key is then encrypted using the public keys of each recipients and concatenated together with the cipher text. Pgp uses a hierarchy of trusted \glspl{ca} as described in \ref{sec:pke}, but also what is called a "web of trust" where users can sign the public keys of eachother to assure authenticity. This way users build a net of users verifying their identity in addition to the trusted \glspl{ca}.

\subsection{Key encapsulation mechanism}
\Gls{kem} \cite{kem_kurosawaP14} is a technique where a random key $K$ is generated together with its encryption $C$ - the encapsulation. This is similar to public key encryption, except that the encryption function does not take a message as input, but only a public key. A random key is then generate, encrypted and returned from the encapsulation function. This is useful for distribution of symmetric keys that can be used again to generate session keys for two or several parties, depending on the encapsulation mechanism. A \gls{kem} consists of three algorithms:
\begin{itemize}
\item \textbf{ Key generation } - generation of the symmetric key used by the \gls{dem}.
\item \textbf{ Encryption } - used to encrypt the generated key, usually using some public key.
\item \textbf{ Decryption } - reveals the symmetric key from the encapsulation.
\end{itemize}

\subsubsection{Multiple \gls{kem}}\label{mkem}
Smart \cite{mkem} proposed to extend the notion of \glspl{kem} to include multiple parties, he named such constructions m\Glspl{kem}. Encapsulating a random generated key for multiple parties with only one encapsulkation. In other words generating one single encapsulation which several users can decrypt with their private key, retriving the symetric key.


\subsubsection{ElGamal Key Encapsulation \cite{elgamal-kem}}\label{subsubsec:elgamal}
ElGamal encryption is a public key encryption scheme as described in \ref{sec:pke}. This construction can be changed slightly to become a simple \gls{kem}. Next ElGamal \gls{kem} is presented as an example of a \gls{kem}.
\begin{description}
\item[Key generation]\hfill \\
Let $q$ be a prime and $G$ a group of prime order $q$. Chose two randoms $g \in G$ and $x \in \mathbb{Z}_q$. The public key $pk = g^x$ is the public key, this is published together with $q and G$. The private secret key is $sk = x$ 
\item[Encryption]\hfill \\
A random $r \in \mathbb{Z}_q$ is chosen. The cipher text is then $C = g^r \in G$ and the key is $k = pk^r \in G$. We say that $C$ now encapsulates $k$, and $C$.
\item[Decryption]\hfill \\
Computes $k$ from $C$ as $k = C^x \in G$. This is correct since \\$k = pk^r = g^{xr} = C^x$ and $ C = g^r$.
\end{description}






\section{Pairing-based encryption}
Let $G$ be a group of prime order $q$ with generator $g$. Chose $x,z,y \in \mathbb{Z}_q$. The \emph{Discrete-logarithm} problem says that it is hard to obtain $x$ from $g^x$ and $g$. Further we have the \emph{\gls{cdh}} which extends this saying that it is hard to calculate $g^{xy}$ from the tuple $(g, g^x, g^y)$. Finally we can say that it is hard to determine if $z=xy$ given $(g, g^x, g^y, g^z)$ - \emph{\gls{ddh}}. These assumptions are used, and relied on, in earlier crypto systems. The systems explored in this project use pairing of the traditional group assumptions. The idea behind this is to use a mapping between two cryptographic groups which allows the creation of new schemes based on the reduction of one of the problems from earlier. The most renowned pairing-based construction is the \emph{bilinear map}. $G_1$ and $G_2$ are groups of prime order $q$. If $e: G_1 \times G_1 \rightarrow G_2$ then the mapping $e$ should have the following properties to be useful: 
\begin{itemize}
\item Bilinearity - for all $h, g \in G_1$ and all $a,b \in \mathbb{Z}_q$, then $e(h^a, g^b) = e(h, g)^{ab}$
\item Non-Degeneracy - if $h \neq 0 \implies e(g,g) \neq 1$
\end{itemize}
The Weil and Tate pairing are the most used pairings where these properties hold. The pairings usually consist of one elliptic curve paired with a finite field. 
The point with all this is that problems in the first group may not all be hard in the pairing group. Discrete-logarithms are still hard since $e(g,g)$, $e(g,g^a)$ $\in G_T$ is as hard as $g,g^a \in G$ where $G_T$ is the pairing group.
For \gls{ddh} though, we can see that to test if $z=xy$ given $g, g^x, g^y, g^z$, we can just check if $e(g, g^z) = e(g^x, g^y)$. \Gls{ddh} is thus replaced by \gls{bddh} which is defined as - given $h, g, g^x, g^y, e(h,g)^z$ it is hard to decide if $xy = z$ \cite{pairing-survey}. These definitions made it possible to implement \gls{ibe} and \gls{abe} as described in the next section.

\section{Identity-based encryption}\label{subsec:IBE}
Public key systems rely on a trusted \gls{ca}, issuing certificates assuring the binding between a public key and a claimed owner. The user generate their key pair themselves, then the public key has to be signed by a trusted \glsdesc{ca}. Now the public key can be verified, assuring that nobody is forging it. Each user has to keep a large archive of keys belonging to whom he wants to communicate. More problems arise when a user wants to declare his key invalid and revoke it. All this makes for a big infrastructure of \glspl{ca} and revocation mechanisms. \Gls{ibe} \cite{DBLP:ibe} introduce an approach where a users id act as the public key, this identity can typically be an e-mail address or a user name. There are no \glspl{ca}, but instead each domain have a \gls{kms} with a master public/secret key pair. The master public key can be used in conjunction with the id of the desired receiver to encrypt the message. The receiver can then decrypt the cipher text using his private key. This private key is extracted by the \gls{kms} from the identity of the specific user. 
The functions of a \gls{ibe} scheme is as following:
\begin{description}
\item[Setup]\hfill \\ Taking some security parameters a master public/secret key pair $(mpk, msk)$ are generated.
\item[Key delegation]\hfill \\Using $mpk$, $msk$ and some $id$ generating a $sk_{id}$ for the specific user. 
\item[Encryption]\hfill \\ Encrypts a message $m$ using $mpk$ and the $id$ of the desired receiver. 
\item[Decryption] \hfill \\Decrypts cipher text $ct$ using $sk_{id}$, obtaining $m$. 
\end{description}
The removal of the \glspl{ca} introduces another problem, since the users no longer generate their own key pair, a lot of power is now in the hands of the \gls{kms}. This can be compared with the power of the \gls{ca}, but algorithms using a \gls{kms} have to take into consideration that this service have complete control over all keys, and can in fact generate any key. The life cycle of a system implementing \gls{ibe} consist of 4 algorithms. In this section two \gls{ibe} systems will be presented, one basic construction proposed by Boneh and Franklin \cite{DBLP:ibe}, and one by Waters \cite{ibe_waters09} which is also part of the Charm framework. Next follows the proposed scheme by Boneh and Franklin while figure \ref{fig:ibenc} displays a demo of the implementation in Charm.


Boneh and Franklin \cite{DBLP:ibe} have proposed a scheme implementing \gls{ibe}, their construction is as following:
\begin{description}
\item[ Setup ]\hfill \\  
Random prime $q$ and groups $G_1$ and $G_2$ of prime order $q$ are generated from the public parameters. The bilinear mapping $e: G_1 \times G_1 \rightarrow G_2$ is also defined. A random element $g \in G_1$ is chosen.\\
Next chose a random $s \in \mathbb{Z}_q^*$. The master public key is then $mpk = g^s$. And Master secret key $msk = s$\\
$H_1 : \{0,1\}^* \rightarrow G_1^*$ is a hash function. Another hash function $H_2 : G_2 \rightarrow \{0,1\}^n$ is chosen for a random $n$.\\
The system's public parameters are $q,G_1,G_2,e,n,g,mpk,H_1,H_2$, which can be published.
\item[Key generation]\hfill \\
Generates a private key $k_{id}$ from a given $id \in \{0,1\}^*$, using $msk = s$, as following. Calculate $h_{id} = H_1(id) \in G_1^*$, and set private key $sk_{id} = h_{id}^s$. This is now the private key of the user with the corresponding id.
\item[Encryption]\hfill \\
Encrypts $M \in \{0,1\}^n$ using the master public key and id of the desired receiver. First computes $h_{id}=H_1(id) \in G_2^*$. Next chose a random $r \in \mathbb{Z}_q^*$, the chiper text is then \\
\centerline{$ct = (g^r, M \oplus H_2(p_{id}^r))$, with $p_{id} = e(h_{id}, mpk) \in G_2^*$}

\item[Decrypt]\hfill \\
Decrypts a cipher text $C$ using a private key corresponding to the decryptors id, $sk_{id}$. Let $ct = (u,v)$, which yields $u = g^r$, and $v = M \oplus H_2(p_{id}^r$, as seen from the encryption function. Then the message is recovered as following:\\
\centerline{$v \oplus H_2(e(sk_{id}, u))$}
\centerline{$(M \oplus H_2(p_{id}^r) \oplus H_2(e(sk_{id}, g^r)) = M$}

This is correct since \\ 
\centerline{ $e(sk_{id}, g^r) = e(h_{id}^s, g^r) = e(h_{id}, g)^{sr} =$ }\\
\centerline{$e(h_{id}, g^s)^r = e(h_{id}, mpk)^r = p_{id}^r$ }
and it is clear that $M$ is actually xored with the hash of $p_{id}^r$ in both the encryption and decryption function.

\end{description}

\par The construction of Boneh and Franklin can does the same job as the scheme by ElGamal in section \ref{subsubsec:elgamal}, with the difference being that the \gls{ibe} scheme uses a master public key and identities to encrypt messages. This scheme could also be changed to be a \gls{kem}, similar to the one presented in \ref{subsubsec:elgamal}, by having the message $M$ be a randomly generated key, and changing the input of the encryption function to only be an id and the $mpk$.



\section{Key Exchange}\label{sec:key_exchange}
A fundamental requirement in many cryptographic schemes is a way of establishing a common secret to be used later to achieve confidentiality or integrity. This is usually solved using a key exchange scheme, which can be between two are a group of parties. In this project the focus is on cases with several users must be allowed. In such group settings there are two types of environment, one when the users are known before the exchange are carried out and they stay the same throughout the life cycle, and one where users join and leave dynamically. Examples of the former are conference calls where the participants are known in advance, before setting up the call, while live chats may be the opposite. This chapter will first show how normal Diffie-Hellman can be utilized to do group key exchange. Next it will be discussed how \glspl{kem} can be used to do multi-party key exchange.

\subsection{Group Diffie-Hellman Key Exchange}\label{subsec:DH}
The Diffie-Hellmann key exchange algorithm in its original form allows two parties to jointly establish a common secret key which later can be used to encrypt traffic and etc. Since the introduction of the 2-party Diffie-Hellmann researchers tried to extend it to support groups of parties \cite{steiner1996diffie, groupDH}. These configurations allow several parties, typically in a multicast group or similar network, to establish a common session key. 
\par In the 2-party Diffie-Hellman a cyclic group G =  $\langle x \rangle$ of prime order $p$ is chosen carefully. Then each party chose a random number, $a$ and $b$, before $g^a$ and $g^b$ can be exchanged and the common secret key $g^{ab}$ computed. The group configuration of the scheme uses the same principle only with several participants as shown in Figure~\ref{fig:dhgroup}. The configuration is the same for $n$ players. The scheme starts off with the first player raising $g$ to the power of his private key and sends this value to the next player in the chain. He then raises the received value to the power of his private key and sends it, plus the intermediate values, on to the next player, this continues until the last player receives the set, he can now compute the session key $g^{x_1,x_2.x_3,...,x_n}$. An attacker would have been able to see all the sent combinations, but none of these combine into the session key. New players cannot easily join or leave since all previous players would have to update their set. 
\par It should be noted that this setup has the limitation of not being authenticated, the users participating does not authenticate themself in any way, so it is impossible to know who you are communicating with. This is why our approach later rely on a \gls{kem} providing authentication. The public key schemes presented in \ref{subsec:pke} will assure you about who you are communicating with, since only the intended user will be able to decrypt. 

\begin{figure}
\centering
\includegraphics[page=2, scale=0.7]{dhgroup.pdf}
\caption{D-H group key exchange}
\label{fig:dhgroup}
\end{figure}



\subsection{Key exchange from \glspl{kem}}\label{subsec:ke-kem}
Gorantla et al. \cite{kem-group-ke} have shown that m\Glspl{kem}, can be used to establish secure shared keys. It is thus a feasible approach to use a functional encryption scheme as a m\Gls{kem} to build a functional key exchange scheme. The idea is that the users exchange encapsulations which all the users will be able to decrypt, obtaining a set of symmetric keys, which in turn can be combined to a shared secret key. This secret key can then be used by the \gls{dem} to encrypt the communication between the users. The implementation presented later will use this approach, using \gls{abe}, extended to a m\Gls{kem}, to exchange a secret key between multiple users.







