\chapter{Background}
\label{chp:background} 
This chapter will present and discuss principles and schemes from which the project later develops. Charm is a framework providing the basis which the implementations later rely. Charm will be introduced first, before continuing on to important principles and constructions which are used in the key exchanges mechanisms later. \Gls{lsss} are used to make attribute-based encryption possible, these ideas will be presented. Moving on with \gls{pke}, showing how this can be used in hybrid encryption schemes with \glspl{kem}. The project rely on using \glspl{kem} to exchange keys, so this and multiple \glspl{kem} will be described with ElGamal as an example. Moving on to paring-based encryption which leads on to identity-based encryption. Finally key exchange and group key exchange built from multiple \gls{kem} will be discussed.

\section{Charm}
Charm \cite{DBLP:Charm13} is a prototyping framework for cryptographic systems. It includes all the tools needed to implement most crypto systems, as well as keeping a collection of reusable code. The idea is to make it sufficiently easy to prototype systems which earlier only existed in research papers without actual implementations. It is of course possible to implement all schemes using other, lower level design methods, which may make for better and more efficient implementations. Most of the tools needed may be available but to combine and make good use of these is not easy. 
\par Charm focuses on being readable and efficient to use. Several existing libraries are used to provide primitives needed, such as pairing groups and modular arithmetic. The design and implementation of Charm is described in detail in "Charm: a framework for rapidly prototyping cryptosystems" \cite{DBLP:Charm13}. This project use Charm mostly as a toolbox to ease the development of functional key exchange, this is practical since Charm include a set of implemented functional encryption schemes.


\section{Linear Secret Sharing}\label{subsec:lsss}
In many cases it may be desirable to use more than one key when encrypting, and later require a subset of these when decrypting. This concept is called secret sharing or secret splitting - a secret is "divided" into $n$ pieces which then is distributed. To recover the message $k$ of these $n$ pieces needs to be present. Secret sharing is often used to store highly sensitive keys, typically private keys of a \gls{ca} or other keys which should not be accessible by a single user alone. For the cause of this project only \gls{lsss} is described as this is a key component in many of the constructions used later. 


\subsection{Shamir Secret  Sharing}\label{sec:secret_sharing}
 Shamir's secret sharing scheme \cite{shamir_share} was one of the first implementations of secret sharing, and acts as an example on how these schemes may look. The main idea behind the scheme is that given $k$ points in a plane $(x_1,y_1), ... (x_k,y_k)$ there is only one polynomial $y(x)$ of degree $k-i$ such that $y(x_i) = y_i$ for all $i$. We can thus chose a prime $p$, larger than the desired number of shares, and a random number $a < p$. Equation 2.1 is the polynomial used, with the secret $m$, with the shares $(x, y(x), p) , x=\left\{ {1,2, ... ,n}\right\}$ of which only $k$ is needed to recover $m$. With $k$ shares we obtain a set of $k$ equations with $k$ unknown which is solved unambiguously.

\begin{equation}
 y(x) = m + a_1*x + a_2*x^2 + ... + a_{k-1} * x^{k-1} 
\end{equation}\label{eq:polynom}


\section{Public Key Encryption}\label{sec:pke}
Public key cryptography or asymmetric cryptography, as describe by ElGamal \cite{elgamal},  allows encryption of messages without the parties sharing a secret key. Each user has a pair of keys, one public and one private key. The private key is used to decrypt and sign messages for authentication, while the public key - known publicly - is used to encrypt messages and verify signatures. 
\begin{itemize}
\item \textbf{Key generation} - takes the security parameters, depending on the implementation, and outputs a public/private key pair.
\item \textbf{ Encryption } - takes the public key of the receiver as input together with the message, outputs a cipher text. Only the corresponding private key can decrypt.
\item \textbf{ Decryption } - uses the private key to decrypt the message.
\end{itemize}

This setup can also be used to achieve message authentication using digital signatures. Either by the use of the same algorithms as mentioned above or with separate ones alongside these. A common problem with public key crypto systems is how you are supposed to trust that a given public key used to sign something really belongs to the claimed owner. This issue is normally dealt with using a trusted \gls{ca} issuing certificates binding a public key to a user identity. The \gls{ca} has a public/private key pair, which is used to sign certificates on request. Initially the \gls{ca} have to publish its public key together with a CA certificate. This is stored in the browsers of users trusting it. A user will typically send a signed certificate request to the \gls{ca}, including the identity to be associated with the public key. The \gls{ca} verifies the request signature and produces a certificate which is signed using the \glspl{ca} own public key. When signing, the user will include this certificate as prof of his identity, which can be verified by anybody in possession of the \glspl{ca} public key and CA certificate. 




\section{Hybrid Public key Encryption}\label{sec:hybrid}
A hybrid encryption scheme \cite{hybrid_enc} consists of a public key encryption technique and a symmetric key encryption technique, from which the former, \gls{kem}, is used to encrypt some key $K$, and the latter, \gls{dem}, encrypts the data. This setup can be applied using a variety of different cryptographic systems for both the \gls{kem} and \gls{dem}. 

\paragraph{Pgp/Gpg}\label{pgp}\cite{openpgp, koch2003gnu} is an extension to the classic public key scheme, combining the speed of symmetric key cryptography with the dynamic nature of public key systems. This is done by generating a random session key which is used to encrypt a message, this key is then encrypted using the public keys of each recipients and concatenated together with the cipher text. Pgp uses a hierarchy of trusted \glspl{ca} as described in \ref{sec:pke}, but also what is called a "web of trust" where users can sign the public keys of eachother to assure authenticity. This way users build a net of users verifying their identity in addition to the trusted \glspl{ca}.

\subsection{Key Encapsulation Mechanism}
\Gls{kem} \cite{kem_kurosawaP14} is a technique where a random key $K$ is generated together with its encryption $C$ - the encapsulation. This is similar to public key encryption, except that the encryption function does not take a message as input, but only a public key. A random key is then generate, encrypted and returned from the encapsulation function. This is useful for distribution of symmetric keys that can be used again to generate session keys for two or several parties, depending on the encapsulation mechanism. A \gls{kem} consists of three algorithms:
\begin{itemize}
\item \textbf{ Key generation } - generation of the symmetric key used by the \gls{dem}.
\item \textbf{ Encryption } - used to encrypt the generated key, usually using some public key.
\item \textbf{ Decryption } - reveals the symmetric key from the encapsulation.
\end{itemize}


\subsubsection{ElGamal Key Encapsulation \cite{elgamal-kem}}\label{subsubsec:elgamal}
ElGamal encryption is a public key encryption scheme as described in \ref{sec:pke}. This construction can be changed slightly to become a simple \gls{kem}. Next ElGamal \gls{kem} is presented as an example of a \gls{kem}. The security of ElGamal rely on the properties of the group from which the encryption are carried out. To be secure both the \gls{cdh} and \gls{ddh} must hold in the underlying group, these properties are defined as follows. Let $G$ be a group of prime order $q$ with generator $g$. Chose $x,z,y \in \mathbb{Z}_q$. The \emph{Discrete-logarithm} problem says that it is hard to obtain $x$ from $g^x$ and $g$. Further we have the \emph{\gls{cdh}} which extends this saying that it is hard to calculate $g^{xy}$ from the tuple $(g, g^x, g^y)$. Finally we can say that it is hard to determine if $z=xy$ given $(g, g^x, g^y, g^z)$ - \emph{\gls{ddh}}. 
\begin{description}
\item[Key generation]\hfill \\
Let $q$ be a prime and $G$ a group of prime order $q$. Chose two randoms $g \in G$ and $x \in \mathbb{Z}_q$. The public key $pk = g^x$ is the public key, this is published together with $q and G$. The private secret key is $sk = x$ 
\item[Encryption]\hfill \\
A random $r \in \mathbb{Z}_q$ is chosen. The cipher text is then $C = g^r \in G$ and the key is $k = pk^r \in G$. We say that $C$ now encapsulates $k$, and $C$.
\item[Decryption]\hfill \\
Computes $k$ from $C$ as $k = C^x \in G$. This is correct since \\$k = pk^r = g^{xr} = C^x$ and $ C = g^r$.
\end{description}




\subsubsection{Multiple \gls{kem}}\label{mkem}
Smart \cite{mkem} proposed to extend the notion of \glspl{kem} to include multiple parties, he named such constructions m\Glspl{kem}. Encapsulating a random generated key for multiple parties with only one encapsulation. In other words generating one single encapsulation which several users can decrypt with their private key, retriving the symetric key.




\section{Pairing-based Encryption}\label{parings}
 The schemes explored in this project use pairings \cite{pairing-survey} of the traditional group assumptions. The idea behind this is to use a mapping between two cryptographic groups which allows the creation of new schemes based on the reduction of one of the problems from earlier. The most renowned pairing-based construction is the \emph{bilinear map}. $G_1$ and $G_2$ are groups of prime order $q$. If $e: G_1 \times G_1 \rightarrow G_2$ then the mapping $e$ should have the following properties to be useful: 
\begin{itemize}
\item Bilinearity - for all $h, g \in G_1$ and all $a,b \in \mathbb{Z}_q$, then $e(h^a, g^b) = e(h, g)^{ab}$
\item Non-Degeneracy - if $h \neq 0 \implies e(g,g) \neq 1$
\end{itemize}
The Weil and Tate pairing are the most used pairings where these properties hold. The pairings usually consist of one elliptic curve paired with a finite field. 
The point with all this is that problems in the first group may not all be hard in the pairing group. Discrete-logarithms are still hard since $e(g,g)$, $e(g,g^a)$ $\in G_T$ is as hard as $g,g^a \in G$ where $G_T$ is the pairing group.
For \gls{ddh} though, we can see that to test if $z=xy$ given $g, g^x, g^y, g^z$, we can just check if $e(g, g^z) = e(g^x, g^y)$. \Gls{ddh} is thus replaced by \gls{bddh} which is defined as - given $h, g, g^x, g^y, e(h,g)^z$ it is hard to decide if $xy = z$. These definitions made it possible to implement \gls{ibe} and \gls{abe} as described in the next section.

\section{Identity-based Encryption}\label{subsec:IBE}
Public key systems rely on a trusted \gls{ca}, issuing certificates assuring the binding between a public key and a claimed owner. The user generate their key pair themselves, then the public key has to be signed by a trusted \glsdesc{ca}. Now the public key can be verified, assuring that nobody is forging it. Each user has to keep a large archive of keys belonging to whom he wants to communicate, or verify them with \glspl{ca} every time. More problems arise when a user wants to declare his key invalid and revoke it. All this makes for a big infrastructure of \glspl{ca} and revocation mechanisms. 
\par \Gls{ibe} \cite{DBLP:ibe} introduce an approach where a users id act as the public key, this identity can typically be an e-mail address or a user name. There are no \glspl{ca}, but instead each domain have a \gls{kms} with a master public/secret key pair. The master public key can be used in conjunction with the id of the desired receiver to encrypt the message. The receiver can then decrypt the cipher text using his private key. This private key is extracted by the \gls{kms} from the identity of the specific user. 
The functions of a \gls{ibe} scheme is as following:
\begin{description}
\item[Setup]\hfill \\ Taking some security parameters a master public/secret key pair $(mpk, msk)$ are generated.
\item[Key delegation]\hfill \\Using $mpk$, $msk$ and some $id$ generating a $sk_{id}$ for the specific user. 
\item[Encryption]\hfill \\ Encrypts a message $m$ using $mpk$ and the $id$ of the desired receiver. 
\item[Decryption] \hfill \\Decrypts cipher text $ct$ using $sk_{id}$, obtaining $m$. 
\end{description}
The removal of the \glspl{ca} introduces another problem, since the users no longer generate their own key pair, a lot of power is now in the hands of the \gls{kms}. This can be compared with the power of the \gls{ca}, but algorithms using a \gls{kms} have to take into consideration that this service have complete control over all keys, and can in fact generate any key. The life cycle of a system implementing \gls{ibe} consist of 4 algorithms. In this section two \gls{ibe} systems will be presented, one basic construction proposed by Boneh and Franklin \cite{DBLP:ibe}, and one by Waters \cite{ibe_waters09} which is also part of the Charm framework. Next follows the proposed scheme by Boneh and Franklin while figure \ref{fig:ibenc} displays a demo of Water's \cite{ibe_waters09} construction using an implementation from Charm.


Boneh and Franklin \cite{DBLP:ibe} have proposed a scheme implementing \gls{ibe}, their construction is as following:
\begin{description}
\item[ Setup ]\hfill \\  
Random prime $q$ and groups $G_1$ and $G_2$ of prime order $q$ are generated from the public parameters. The bilinear mapping $e: G_1 \times G_1 \rightarrow G_2$ is also defined. A random element $g \in G_1$ is chosen.\\
Next chose a random $s \in \mathbb{Z}_q^*$. The master public key is then $mpk = g^s$. And Master secret key $msk = s$\\
$H_1 : \{0,1\}^* \rightarrow G_1^*$ is a hash function. Another hash function $H_2 : G_2 \rightarrow \{0,1\}^n$ is chosen for a random $n$.\\
The system's public parameters are $q,G_1,G_2,e,n,g,mpk,H_1,H_2$, which can be published.
\item[Key generation]\hfill \\
Generates a private key $k_{id}$ from a given $id \in \{0,1\}^*$, using $msk = s$, as following. Calculate $h_{id} = H_1(id) \in G_1^*$, and set private key $sk_{id} = h_{id}^s$. This is now the private key of the user with the corresponding id.
\item[Encryption]\hfill \\
Encrypts $M \in \{0,1\}^n$ using the master public key and id of the desired receiver. First computes $h_{id}=H_1(id) \in G_2^*$. Next chose a random $r \in \mathbb{Z}_q^*$, the chiper text is then \\
\centerline{$ct = (g^r, M \oplus H_2(p_{id}^r))$, with $p_{id} = e(h_{id}, mpk) \in G_2^*$}

\item[Decrypt]\hfill \\
Decrypts a cipher text $C$ using a private key corresponding to the decryptors id, $sk_{id}$. Let $ct = (u,v)$, which yields $u = g^r$, and $v = M \oplus H_2(p_{id}^r$, as seen from the encryption function. Then the message is recovered as following:\\
\centerline{$v \oplus H_2(e(sk_{id}, u))$}
\centerline{$(M \oplus H_2(p_{id}^r) \oplus H_2(e(sk_{id}, g^r)) = M$}

This is correct since \\ 
\centerline{ $e(sk_{id}, g^r) = e(h_{id}^s, g^r) = e(h_{id}, g)^{sr} =$ }\\
\centerline{$e(h_{id}, g^s)^r = e(h_{id}, mpk)^r = p_{id}^r$ }
and it is clear that $M$ is actually xored with the hash of $p_{id}^r$ in both the encryption and decryption function.

\end{description}

\par The construction of Boneh and Franklin can does the same job as the scheme by ElGamal in section \ref{subsubsec:elgamal}, with the difference being that the \gls{ibe} scheme uses a master public key and identities to encrypt messages. This scheme relies on the \gls{bddh} as described in section \ref{parings}. ElGamal encryption could also be changed to be a \gls{kem}, similar to the one presented in \ref{subsubsec:elgamal}, by having the message $M$ be a randomly generated key, and changing the input of the encryption function to only be an id and the $mpk$.



\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\begin{figure}[H]
\begin{lstlisting}[language=bash, xleftmargin=2em, frame=single, framexleftmargin=1.5em, breaklines=true, numbers=left, numbersep=5pt, numberstyle=\tiny\color{mygray}]

>>> from charm.toolbox.pairinggroup import PairingGroup, GT
>>> from charm.schemes.ibenc.ibenc_waters09 import DSE09
>>> group = PairingGroup('SS512')
>>> ibe = DSE09(group)
>>> mpk, msk = ibe.setup()
>>> ID = "student@stud.ntnu.no"
>>> secret_key = ibe.keygen(mpk, msk, ID)
>>> msg = group.random(GT)
>>> ct = ibe.encrypt(mpk, msg, ID)
>>> decrypted_msg = ibe.decrypt(ct, secret_key)
>>> msg == decrypted_msg
True
>>> 

\end{lstlisting}
\caption{Demo run of the identity-based encryption by Waters from Charm.}
\label{fig:ibenc}
\end{figure}

First the required dependencies are imported from the Charm toolbox, in this example the pairing group and the \gls{ibe} class. On line 4 the pairing group is initiated with a elliptic curve with a 512-bit base - thus "SS512". Next the class object is initiated using the previously created group object. Line 6 to 13 demonstrate a \gls{ibe} cycle with setup, keygen, encryption and decryption.
Notice that anybody can encrypt a message for any user without having a public key stored locally, we simply use the master public key together with the identity of the recipient. This removes a lot of overhead known from \gls{pki}, we now only need one public key for each domain. \Gls{ibe} is a somewhat more intuitive scheme, than normal public key encryption, since the identity of the recipients is used as the public key, thus no connection between different public keys and user identities have to be stored.
\par This project uses a generalization of \gls{ibe} called \gls{abe} as the basis of the later presented construction. \Gls{abe} is in short the same is \gls{ibe} with the difference being that it allows several attributes to be used as the public key, instead of only an id as in \gls{ibe}. \Gls{abe} will be described in dept in the next chapter.

\section{Key Exchange}\label{sec:key_exchange}
A fundamental requirement in many cryptographic schemes is a way of establishing a common secret to achieve confidentiality or integrity. This is usually solved using a key exchange scheme, which can be between two or a group of parties. In this project the focus is on cases where several users must be allowed. In such group settings there are two types of environments, one where the users are known before the exchange are carried out and they stay the same throughout the life cycle, and one where users join and leave dynamically. Examples of the former are conference calls where the participants are known in advance, before setting up the call, while live chats may be the opposite. This section will first show how normal Diffie-Hellman can be utilized to do group key exchange. Before discussing how \glspl{kem} can be used to do multi-party key exchange.

\subsection{Group Diffie-Hellman Key Exchange}\label{subsec:DH}
The Diffie-Hellmann key exchange algorithm in its original form allows two parties to establish a common secret key which later can be used to encrypt traffic. Since the introduction of the 2-party Diffie-Hellmann researchers have tried to extend it to support groups of parties \cite{steiner1996diffie, groupDH}. These configurations allow several parties, typically in a multicast group or similar network, to establish a common session key. 
\par In the 2-party Diffie-Hellman a group G of prime order $p$ is chosen carefully. Then each party chose a random number, $a$ and $b$, then $g^a$ and $g^b$ can be exchanged and the common secret key $g^{ab}$ computed, by both. The group configuration of the scheme uses the same principle only with several participants as shown in Figure~\ref{fig:dhgroup}. The configuration is the same for $n$ players. The scheme starts off with the first player raising $g$ to the power of his private key and sends this value to the next player in the chain. He then raises the received value to the power of his private key and sends it, plus the intermediate values, on to the next player, this continues until the last player receives the set, he can now compute the session key $g^{x_1,x_2.x_3,...,x_n}$. An attacker would have been able to see all the sent combinations, but none of these combine into the session key. New players cannot easily join or leave since all previous players would have to update their set. 
\par It should be noted that this setup has the limitation of not being authenticated, the users participating does not authenticate themself in any way, so it is impossible to know who you are communicating with. This is why this project's approach rely on a \gls{kem} providing implicit authentication. Public key schemes as presented in \ref{sec:pke} will assure you about who you are communicating with, since only the intended user will be able to decrypt. 

\begin{figure}
\centering
\includegraphics[page=2, scale=0.7]{dhgroup.pdf}
\caption{D-H group key exchange}
\label{fig:dhgroup}
\end{figure}



\subsection{Key Exchange from Key Encapsulation}\label{subsec:ke-kem}
Gorantla et al. \cite{kem-group-ke} have shown that m\Glspl{kem}, can be used to establish secure shared keys. It is thus a feasible approach to use a functional encryption scheme as a m\Gls{kem} to build a functional key exchange scheme. The idea is that the users exchange encapsulations which all the users will be able to decrypt, obtaining a set of symmetric keys, which in turn can be combined to a shared secret key. This secret key can then be used by the \gls{dem} to encrypt the communication between the users. The implementation presented later will use this approach, using \gls{abe}, extended to a m\Gls{kem}, to exchange a secret key between multiple users.







